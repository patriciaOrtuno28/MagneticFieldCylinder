%% Constants and observation points:
clear variables
vacuum = 4*pi*10^(-7); %Magnetic vacuum permeability
R=1; %Radius of the cylinder
H=0.5; %Height of the cylinder
%Variables that will store each component of the magnetic momentum
mx=0;
my=0;
mz=0;
%Matrix for each component of the magnetic field by Biot-Savart
Bxx=[];
Byx=Bxx;
Bzx=Bxx;
%Matrix for the magnetic field generated by magnetic momentum
B_fw=Bzx;
warning('off'); 

%% Calculation of the magnetic fields by both methods:
%Biot-Savart:
for z=linspace(2*H,20*H,16) %It will be particularized in the z axis, so this is the only
                            %non-nule observation point
    y=0.0001;
        x=0.0001;
        [funx,funy,funz]=body_comp(x,y,z); %Calling the function generated at the end of this code
             
            %Magnetic field of each component (x,y,z)
            Bxx = [Bxx (vacuum/(4*pi))*(integral3(funx,0,R,0,2*pi,-H/2,H/2))];
            Byx = [Byx (vacuum/(4*pi))*(integral3(funy,0,R,0,2*pi,-H/2,H/2))];
            Bzx = [Bzx (vacuum/(4*pi))*(integral3(funz,0,R,0,2*pi,-H/2,H/2))];

end

%Magnetic momentum:

[funxm,funym,funzm]=body_m; %Calling the  otherfunction generated at the end of this code
             
        %Each element of the magnetic momentum (x,y,z)
       mx = integral3(funxm,0,R,0,2*pi,-H/2,H/2); %=0
       my = integral3(funym,0,R,0,2*pi,-H/2,H/2); %=0
       mz = integral3(funzm,0,R,0,2*pi,-H/2,H/2); %Different from 0, we will work with this component
            
for r=linspace(2*H,20*H,16) 
    theta=0; % By saying theta = 0, we are particularizing this function for the z axis.
    if(r~=0) %Condition to avoid singularities
        %Matrix to store the magnetic field being created
        B_fw =[B_fw (vacuum/(4*pi*r^3))*((((3*(cos(theta))^2)/r^2)-1)*mz)];
    end
end

%% Plot of comparison between both methods:
Mod = sqrt(Bxx.^2+Byx.^2+Bzx.^2); %Module of the components of the magnetic field
                                    %generated by Biot-Savart

plot(Mod,'b');
xlabel('x(m)'),ylabel('B(T)'),title('Comparison - Points away from the z axis');
hold on
plot(B_fw,'g');
hold off
legend('Biot-Savart','Magnetic-Moment');
%Note: we will see how, as both functions get closer to the horizontal
%axis, they are practically the same, and, amongst zero there are clear
%differences, which will be explained in both the presentation and the
%memory of this project

%% Functions for both methods:

%Biot-Savart:
function[funx,funy,funz]=body_comp(x,y,z)

%Definition of constants needed
R=1;
H=0.5;
n=2;
J0=1;
            %All functions will be represented in terms of ro',phi' and z',
            %for the cylindrical coordinate system
            
            %Position vector for x,y and z
            position_vector_x = @ (rop,phip,zp) x-rop.*cos(phip);
            position_vector_y = @ (rop,phip,zp) y-rop.*sin(phip);
            position_vector_z = @ (rop,phip,zp) z-zp;

              %Modulus of the position vector, with a small epsilon added in
            %the end to avoid possible singularities (divisions by zero)
            modulus_position_vector =@(rop,phip,zp) ((position_vector_x(rop,phip,zp)).^2+(position_vector_y(rop,phip,zp)).^2+(position_vector_z(rop,phip,zp)).^2)+0.01;
           
            %Components x,y and z of the current distribution
            Jx=@(rop,phip,zp) J0*pi*((R-rop)./H).*(sin((pi.*zp)./H)).*cos(phip) - ((zp./H).^n).*sin(phip);
            Jy=@(rop,phip,zp) J0*pi*((R-rop)./H).*(sin((pi.*zp)./H)).*sin(phip) + ((zp./H).^n).*cos(phip);
            Jz=@(rop,zp) J0*(R-2.*rop)./(rop).*(cos((pi.*zp)./H));
            
            %Crossproducts of x,y and z of the current distribution with
            %the position vector
            crossproduct_x = @(rop,phip,zp) Jy(rop,phip,zp).*position_vector_x(rop,phip,zp)-Jz(rop,zp).*position_vector_y(rop,phip,zp);
            crossproduct_y = @(rop,phip,zp) position_vector_x(rop,phip,zp).*Jz(rop,zp)-Jx(rop,phip,zp).*position_vector_z(rop,phip,zp);
            crossproduct_z = @(rop,phip,zp) Jx(rop,phip,zp).*position_vector_y(rop,phip,zp)-Jy(rop,phip,zp).*position_vector_x(rop,phip,zp);
            
            %The body of the integral for each component x,y and z
            funx = @(rop,phip,zp) (crossproduct_x(rop,phip,zp).*rop)./(modulus_position_vector(rop,phip,zp).^3);
            funy = @(rop,phip,zp) (crossproduct_y(rop,phip,zp).*rop)./(modulus_position_vector(rop,phip,zp).^3);
            funz = @(rop,phip,zp) (crossproduct_z(rop,phip,zp).*rop)./(modulus_position_vector(rop,phip,zp).^3); 
end

%Magnetic momentum:
function[funxm,funym,funzm]=body_m
%Definition of constants needed
R=1;
H=0.5;
n=2;
J0=1;
            %All functions will be represented in terms of ro',phi' and z',
            %for the cylindrical coordinate system
            
            %Position vector for x,y and z
            position_vector_x =@(rop,phip,zp) rop.*cos(phip);
            position_vector_y =@(rop,phip,zp) rop.*sin(phip);
            position_vector_z =@(rop,phip,zp) zp;
            
            %Components x,y and z of the current distribution
            Jx=@(rop,phip,zp) J0*pi*((R-rop)./H).*(sin((pi.*zp)./H)).*cos(phip) - ((zp./H).^n).*sin(phip);
            Jy=@(rop,phip,zp) J0*pi*((R-rop)./H).*(sin((pi.*zp)./H)).*sin(phip) + ((zp./H).^n).*cos(phip);
            Jz=@(rop,zp) J0*(R-2.*rop)./(rop).*(cos((pi.*zp)./H));
            
            %Crossproducts of x,y and z of the current distribution with
            %the position vector
            crossproduct_x = @(rop,phip,zp) -Jy(rop,phip,zp).*position_vector_z(rop,phip,zp)+Jz(rop,zp).*position_vector_y(rop,phip,zp);
            crossproduct_y = @(rop,phip,zp) position_vector_z(rop,phip,zp).*Jx(rop,phip,zp)-Jz(rop,zp).*position_vector_x(rop,phip,zp);
            crossproduct_z = @(rop,phip,zp) Jy(rop,phip,zp).*position_vector_x(rop,phip,zp)-Jx(rop,phip,zp).*position_vector_y(rop,phip,zp);
            
            %The body of the integral for each component x,y and z
            funxm = @(rop,phip,zp) 0.5.*crossproduct_x(rop,phip,zp);
            funym = @(rop,phip,zp) 0.5.*crossproduct_y(rop,phip,zp);
            funzm = @(rop,phip,zp) 0.5.*crossproduct_z(rop,phip,zp);
            
end

